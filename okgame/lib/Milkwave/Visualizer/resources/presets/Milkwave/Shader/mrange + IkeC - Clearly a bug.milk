MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// mrange + IkeC - Clearly a bug / https://www.shadertoy.com/view/33cGDj
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=shader_body {
comp_7=  float4 O = 0;
comp_8=  // CONV: Center on screen, then try some aspect correction
comp_9=  uv = (uv*2) - 1;
comp_10=  uv *= aspect.xy;
comp_11=  
comp_12=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_13=  uv = float2(uv.x, -uv.y);
comp_14=
comp_15=  uv.y-=0.4;
comp_16=  float2 C = uv;
comp_17=  C.y+=0.18;  
comp_18=
comp_19=  // contraction
comp_20=  #ifdef bass_smooth
comp_21=    float fac = (int)vis_version > 2 ? 0.1*vis_intensity+vis_shift : (smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att)*0.3)*vis_intensity+vis_shift;
comp_22=  #else
comp_23=    float fac = smoothstep(0,2,bass_att)*0.1;
comp_24=  #endif
comp_25=  
comp_26=  float
comp_27=  i
comp_28=  // Loop counter (starts at 0)
comp_29=  , d
comp_30=  // Distance to nearest surface
comp_31=  , z = frac(dot(C,sin(C)))-.5
comp_32=  // Ray distance + noise for anti-banding
comp_33=  ;
comp_34=  float4
comp_35=  o
comp_36=  // Accumulated color/lighting
comp_37=  , p
comp_38=  // Current 3D position along ray
comp_39=  ;
comp_40=  for(
comp_41=  float2 r = uv.xy
comp_42=  // Screen resolution
comp_43=  ; ++i < 77.
comp_44=  ; z -= .6*d
comp_45=  // Step forward (larger steps when far from surfaces)
comp_46=  )
comp_47=  // Convert 2D pixel to 3D ray direction
comp_48=  p = float4(z*normalize(float3(C-.5*r,r.y)),.1*time)
comp_49=
comp_50=  // Move through 3D space over time
comp_51=  , p.z += time
comp_52=
comp_53=  // Save position for lighting calculations
comp_54=  , O = p
comp_55=
comp_56=  // Apply rotation matrices to create fractal patterns
comp_57=  // (These transform the 3D coordinates in interesting ways)
comp_58=  , p.xy = mul(p.xy, transpose(float2x2(cos(2.+O.z+float4(fac,11,33,0)))))
comp_59=
comp_60=  // This was originally a bug in the matrix calculation
comp_61=  // The incorrect transformation created an unexpectedly interesting pattern
comp_62=  // Bob Ross would call this a "happy little accident"
comp_63=  , p.xy = mul(p.xy, transpose(float2x2(cos(O+float4(0,11,33,0)))))
comp_64=
comp_65=  // Calculate color based on position and space distortion
comp_66=  // The sin() creates a nice looking palette, division by dot() creates falloff
comp_67=  , O = (1+sin(.5*O.z+length(p-O)+float4(0,4,3,6)))
comp_68=  / (.5+2.*dot(O.xy,O.xy))
comp_69=
comp_70=  // Domain repetition, repeats the single line and the 2 planes infinitely
comp_71=  , p = abs(frac(p)-.5)
comp_72=
comp_73=  // Calculate distance to nearest surface
comp_74=  // This combines a cylinder (length(p.xy)-.125) with 2 planesbox (min(p.x,p.y))
comp_75=  , d = abs(min(length(p.xy)-.125,min(p.x,p.y)+1e-3))+1e-3
comp_76=
comp_77=  // Add lighting contribution (brighter when closer to surfaces)
comp_78=  , o += O.w/d*O
comp_79=  ;
comp_80=
comp_81=  // tanh() compresses the accumulated brightness to 0-1 range
comp_82=  // (Like HDR tone mapping in photography)
comp_83=  ret = tanh(o/2e4);
comp_84=}
