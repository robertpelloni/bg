MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
comp_1=// macbooktall + IkeC - fractal trees gif / https://www.shadertoy.com/view/llXfRr
comp_2=// Transpiled to HLSL using Milkwave
comp_3=
comp_4=#define tx sin(time)*0.5+1
comp_5=
comp_6=float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_7=float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_8=float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_9=float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_10=
comp_11=#define MAXDIST 50
comp_12=#define iterations 40
comp_13=
comp_14=struct Ray {
comp_15=  float3 ro;
comp_16=  float3 rd;
comp_17=};
comp_18=
comp_19=float3 hue(float3 color, float shift) {
comp_20=
comp_21=  const float3  kRGBToYPrime = float3 (0.299, 0.587, 0.114);
comp_22=  const float3  kRGBToI     = float3 (0.596, -0.275, -0.321);
comp_23=  const float3  kRGBToQ     = float3 (0.212, -0.523, 0.311);
comp_24=
comp_25=  /*
comp_26=  const float3  kRGBToYPrime = float3 (1,1,1);
comp_27=  const float3  kRGBToI     = float3 (1,1,1);
comp_28=  const float3  kRGBToQ     = float3 (1,1,1);
comp_29=  */
comp_30=
comp_31=  const float3  kYIQToR   = float3 (1.0, 0.956, 0.621);
comp_32=  const float3  kYIQToG   = float3 (1.0, -0.272, -0.647);
comp_33=  const float3  kYIQToB   = float3 (1.0, -1.107, 1.704);
comp_34=  /*
comp_35=  const float3  kYIQToR   = float3 (11,0,0);
comp_36=  const float3  kYIQToG   = float3 (11,0,0);
comp_37=  const float3  kYIQToB   = float3 (11,0,0);
comp_38=  */
comp_39=
comp_40=  float   YPrime  = dot (color, kRGBToYPrime);
comp_41=  float   I      = dot (color, kRGBToI);
comp_42=  float   Q      = dot (color, kRGBToQ);
comp_43=
comp_44=  float   hue     = atan2 (Q, I);
comp_45=  float   chroma  = sqrt (I * I + Q * Q);
comp_46=
comp_47=  hue += shift;
comp_48=
comp_49=  Q = chroma * sin (hue);
comp_50=  I = chroma * cos (hue);
comp_51=
comp_52=  float3    yIQ   = float3 (YPrime, I, Q);
comp_53=  color.r = dot (yIQ, kYIQToR);
comp_54=  color.g = dot (yIQ, kYIQToG);
comp_55=  color.b = dot (yIQ, kYIQToB);
comp_56=
comp_57=  return color;
comp_58=}
comp_59=
comp_60=float opU( float d1, float d2 )
comp_61={
comp_62=  return min(d1,d2);
comp_63=}
comp_64=
comp_65=float smin( float a, float b, float k ){
comp_66=  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
comp_67=  return lerp( b, a, h ) - k*h*(1.0-h);
comp_68=}
comp_69=
comp_70=float length6( float3 p )
comp_71={
comp_72=  p = p*p*p; p = p*p;
comp_73=  return pow( p.x + p.y + p.z, 1.0/6.0 );
comp_74=}
comp_75=
comp_76=float fPlane(float3 p, float3 n, float distanceFromOrigin) {
comp_77=  return dot(p, n) + distanceFromOrigin;
comp_78=}
comp_79=
comp_80=void pR(inout float2 p, float a) {
comp_81=  p = cos(a)*p + sin(a)*float2(p.y, -p.x);
comp_82=}
comp_83=
comp_84=float fractal(float3 p)
comp_85={
comp_86=  float d = time*5. - p.z;
comp_87=  p=p.yxz;
comp_88=  pR(p.yz, 1.570795);
comp_89=  p.x += 6.5;
comp_90=
comp_91=  p.yz = mod_conv(abs(p.yz)-.0, 20.) - 10.;
comp_92=  float scale = 1.25;
comp_93=
comp_94=  p.xy /= (1.+d*d*0.0005);
comp_95=
comp_96=  float l = 0.;
comp_97=
comp_98=  for (int i=0; i<iterations; i++) {
comp_99=    p.xy = abs(p.xy);
comp_100=    p = p*scale + float3(-3. + d*0.0095,-1.5,-.5);
comp_101=
comp_102=    pR(p.xy,0.35-d*0.015);
comp_103=    pR(p.yz,0.5+d*0.02);
comp_104=
comp_105=    l =length6(p);
comp_106=  }
comp_107=
comp_108=  return l*pow(scale, -float(iterations))-.15;
comp_109=}
comp_110=
comp_111=float2 map(float3 pos)
comp_112={
comp_113=  float dist = 10.;
comp_114=  dist = opU(dist, fractal(pos));
comp_115=  dist = smin(dist, fPlane(pos,float3(0.0,1.0,0.0),10.), 4.6);
comp_116=
comp_117=  return float2(dist, 0.);
comp_118=}
comp_119=
comp_120=float3 vmarch(Ray ray, float dist)
comp_121={
comp_122=  float3 p = ray.ro;
comp_123=  float2 r = float2(0., 0.);
comp_124=  float3 sum = float3(0, 0, 0);
comp_125=
comp_126=  float3 c = hue(float3(0,0,1),5.5);
comp_127=
comp_128=  for( int i=0; i<20; i++ )
comp_129=  {
comp_130=    r = map(p);
comp_131=    // CONV: break is unsupported, see Milkwave manual for details
comp_132=    if (r.x > .01) i=20;
comp_133=    p += ray.rd*.015;
comp_134=    float3 col = c;
comp_135=    col.rgb *= smoothstep(.0,0.15,-r.x);
comp_136=    sum += abs(col)*.5;
comp_137=  }
comp_138=
comp_139=  return sum;
comp_140=}
comp_141=
comp_142=float2 march(Ray ray)
comp_143={
comp_144=  const int steps = 50;
comp_145=  const float prec = 0.001;
comp_146=  float2 res = float2(0., 0.);
comp_147=
comp_148=  for (int i = 0; i < steps; i++)
comp_149=  {
comp_150=    float2 s = map(ray.ro + ray.rd * res.x);
comp_151=
comp_152=    if (res.x > MAXDIST || s.x < prec)
comp_153=    {
comp_154=      i=steps;
comp_155=    }
comp_156=
comp_157=    res.x += s.x;
comp_158=    res.y = s.y;
comp_159=
comp_160=  }
comp_161=
comp_162=  return res;
comp_163=}
comp_164=
comp_165=float3 calcNormal(float3 pos)
comp_166={
comp_167=  const float3 eps = float3(0.005, 0.0, 0.0);
comp_168=
comp_169=  return normalize(
comp_170=  float3(map(pos + eps).x - map(pos - eps).x,
comp_171=  map(pos + eps.yxz).x - map(pos - eps.yxz).x,
comp_172=  map(pos + eps.yzx).x - map(pos - eps.yzx).x )
comp_173=  );
comp_174=}
comp_175=
comp_176=float4 render(Ray ray)
comp_177={
comp_178=  // background
comp_179=  float3 bgcol = float3(0.7,0,0);
comp_180=  
comp_181=  #ifdef bass_smooth
comp_182=    float fac = (int)vis_version > 2 ? 0.2*vis_intensity+vis_shift : (smoothstep(0,2,(int)vis_version == 1 ? bass_smooth : bass_att)*0.4)*vis_intensity+vis_shift;
comp_183=  #else
comp_184=    float fac = smoothstep(0,2,vol_att)*0.2;
comp_185=  #endif
comp_186=  
comp_187=  bgcol.r -= fac/2;
comp_188=  bgcol.g += fac;
comp_189=
comp_190=  float3 col = bgcol;
comp_191=  float2 res = march(ray);
comp_192=
comp_193=  if (res.x > MAXDIST)
comp_194=  {
comp_195=    return float4(col, 50.);
comp_196=  }
comp_197=
comp_198=  else {
comp_199=    float3 pos = ray.ro+res.x*ray.rd;
comp_200=    ray.ro = pos;
comp_201=    col = vmarch(ray, res.x);
comp_202=
comp_203=    col = lerp(col, bgcol, clamp(res.x/50., 0., 1.));
comp_204=    return float4(col, res.x);
comp_205=  }
comp_206=}
comp_207=
comp_208=float3x3 camera(in float3 ro, in float3 rd, float rot)
comp_209={
comp_210=  float3 forward = normalize(rd - ro);
comp_211=  float3 worldUp = float3(sin(rot), cos(rot), 0.0);
comp_212=  float3 x = normalize(cross(forward, worldUp));
comp_213=  float3 y = normalize(cross(x, forward));
comp_214=  return float3x3(x, y, forward);
comp_215=}
comp_216=
comp_217=shader_body {
comp_218=  float4 fragColor = 0;
comp_219=  float2 fragCoord  = uv;
comp_220=  // CONV: Center on screen, then try some aspect correction
comp_221=  uv = (uv*2) - 1;
comp_222=  uv.x+= 0.2;
comp_223=  uv.y+= -0.9;
comp_224=  uv *= aspect.xy;
comp_225=  // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_226=  uv = float2(uv.x, -uv.y);
comp_227=
comp_228=  // float2 uv = fragCoord.xy / texsize.xy;
comp_229=  uv = uv * 2.0 - 1.0;
comp_230=  float3 camPos = float3(3., -1.5, time*5.);
comp_231=  float3 camDir = camPos+float3(-1.25,0.1, 1.);
comp_232=  float3x3 cam = camera(camPos, camDir, 0.);
comp_233=
comp_234=  float3 rayDir = mul(cam, normalize(float3(uv, 0.8)));
comp_235=
comp_236=  Ray ray;
comp_237=  ray.ro = camPos;
comp_238=  ray.rd = rayDir;
comp_239=
comp_240=
comp_241=    ray.rd.x -= 0.03;
comp_242=
comp_243=    // fly up and down
comp_244=    ray.ro.y += sin(time*0.2)*5;
comp_245=    
comp_246=    //ray.rd.y += fac;
comp_247=
comp_248=  float4 col = render(ray);
comp_249=  
comp_250=  ret = float4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));
comp_251=}
