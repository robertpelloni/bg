MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=2
[preset00]
fRating=5.000
fGammaAdj=1.460
fDecay=0.935
fVideoEchoZoom=1.007
fVideoEchoAlpha=0.500
nVideoEchoOrientation=2
nWaveMode=15
bAdditiveWaves=1
bWaveDots=0
bWaveThick=1
bModWaveAlphaByVolume=0
bMaximizeWaveColor=1
bTexWrap=1
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=1
bDarken=1
bSolarize=0
bInvert=0
fWaveAlpha=0.001
fWaveScale=0.625
fWaveSmoothing=0.900
fWaveParam=0.000
fModWaveAlphaStart=0.880
fModWaveAlphaEnd=1.980
fWarpAnimSpeed=1.000
fWarpScale=1.331
fZoomExponent=1.00000
fShader=1.000
zoom=0.99950
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=0.00900
sx=1.00000
sy=1.00000
wave_r=0.000
wave_g=0.000
wave_b=0.000
wave_x=0.500
wave_y=0.500
ob_size=0.500
ob_r=0.010
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.260
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=64.000
nMotionVectorsY=48.000
mv_dx=0.000
mv_dy=0.000
mv_l=1.000
mv_r=1.060
mv_g=1.000
mv_b=0.819
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
per_frame_init_1=x1 = 2;
per_frame_init_2=y1= 2;
per_frame_init_3=z1 = 2;
per_frame_1=// raytraced sphere code
per_frame_2=
per_frame_3=d = 20; // distance of the sphere, the farther you're away the more you'll see on the horizon
per_frame_4=z = 4; // distance of the pane where the scene is projected on, wider distance = smaller apex angle of the camera, very small distances = fish eyes view
per_frame_5=
per_frame_6=zz = 1 + bass_att*0; // linear zoom
per_frame_7=
per_frame_8=pi = asin(1)*2;
per_frame_9=pi2inv = 0.5/pi;
per_frame_10=maskangle = asin( 1/d);
per_frame_11=q32 = maskangle; // hit = (cameras angle < mask_angle)
per_frame_12=q31 = d;
per_frame_13=q30 = z;
per_frame_14=q29 = pi2inv;
per_frame_15=q28 = pi;
per_frame_16=q27 = 1/zz;
per_frame_17=
per_frame_18=v = 0.4;
per_frame_19=j1 = j1*0.95 + sqr(bass*4)*v;
per_frame_20=j2 = j2*0.95 + sqr(mid*4)*v;
per_frame_21=j3 = j3*0.95 + sqr(treb*4)*v;
per_frame_22=
per_frame_23=n = n + j1*0.0152;
per_frame_24=n1 = n1 + j2*0.0152;
per_frame_25=n2 = n2 + j3*0.0152;
per_frame_26=
per_frame_27=vol=(bass+mid+treb)*0.25;
per_frame_28=vol=vol;
per_frame_29=q3=vol;
per_frame_30=mtime = mtime+vol*0.01;
per_frame_31=q1=mtime;
per_frame_32=
per_frame_33=zoom = zoom + 0.015*vol;
per_frame_34=
per_frame_35=w1 = n*0.01;    // solid angles to rotate the sphere in its origin
per_frame_36=w2 = n1*0.01;
per_frame_37=w3 = n2*0.01;
per_frame_38=
per_frame_39=q20 = cos(w1);
per_frame_40=q21 = sin(w1);
per_frame_41=q22 = cos(w2);
per_frame_42=q23 = sin(w2);
per_frame_43=q24 = cos(w3);
per_frame_44=q25 = sin(w3);
warp_1=`//Shader by Altunenes
warp_2=`//https://www.shadertoy.com/view/w33GRl
warp_3=`//Ported to MilkDrop by MilkDrop2077
warp_4=`
warp_5=`// Noise function
warp_6=`float n(float2 p) {
warp_7=`   return sin(p.x*3.0+sin(p.y*2.7))*cos(p.y*1.1+cos(p.x*2.3));
warp_8=`}
warp_9=`
warp_10=`// Fractal function
warp_11=`float f(float3 p) {
warp_12=`    float v = 0.0, a = 1.0;
warp_13=`    for(int i=0; i<7; i++) {
warp_14=`       v += n(p.xy+p.z*0.5)*a;
warp_15=`       p *= 2.0;
warp_16=`       a *= 0.5;
warp_17=`    }
warp_18=`    return v;
warp_19=`}
warp_20=`
warp_21=`shader_body {
warp_22=`    // Initialize output
warp_23=`    ret = float4(0, 0, 0, 1);
warp_24=`    
warp_25=`    // Coordinate setup with aspect ratio correction
warp_26=`    float aspect = aspect.x/aspect.y;
warp_27=`    uv = (uv.xy-0.5)*float2(aspect,1.0);
warp_28=`    uv = -uv; //Correctly flip UV
warp_29=`    float3 o = float3(0,0,0);
warp_30=`    float z = 0.0, d = 0.0, t = time;
warp_31=`    float N = 0.0;
warp_32=`    
warp_33=`    // Raymarching loop
warp_34=`    for(int i=0; i<50; i++) {
warp_35=`        // Ray setup
warp_36=`        float3 p = z*normalize(float3(uv.x, uv.y, 1.0));
warp_37=`        p.z += t;
warp_38=`        
warp_39=`        // Rotation matrix inspired by mrange's work
warp_40=`        float angle = p.z;
warp_41=`        float2x2 R = transpose(float2x2(cos(angle), -sin(angle), 
warp_42=`                             sin(angle), cos(angle)));
warp_43=`        // In GLSL is column-major order and in HLSL, row-major order,
warp_44=`        // So we transpose the matrix with transpose() to be the same as GLSL.
warp_45=`
warp_46=`        p.xy = mul(p.xy, R);
warp_47=`        
warp_48=`        // Fractal evaluation
warp_49=`        N = f(p+q1/2 + t*0.1);
warp_50=`        d = length(p.xy)-1.0+N*0.3;
warp_51=`        p.z = fmod(p.z,4.0+cos(q6))-3.0;
warp_52=`        d = abs(d)+0.01;
warp_53=`        
warp_54=`        // Color composition
warp_55=`        float3 c = float3(0.1,0.3,0.8)/(length(p.xy+N+bass_att)*0.8);
warp_56=`        c += float3(0.8,0.4,0.2)/(length(p.xz+N)*0.5);
warp_57=`        c += float3(1.0,1.0,2.0)*(0.5+0.5*sin(N*1.0+t));
warp_58=`        
warp_59=`        // Accumulate color with falloff
warp_60=`        o += c/d*0.12;
warp_61=`        z += d*0.6;
warp_62=`    }
warp_63=`    
warp_64=`    // Final color processing
warp_65=`    ret.rgb = tanh(o*0.001);
warp_66=`}
comp_1=`shader_body
comp_2=`{
comp_3=`    ret = tex2D(sampler_main, uv).xyz;
comp_4=`ret*=2;
comp_5=`//ret-=0.2;
comp_6=`}
