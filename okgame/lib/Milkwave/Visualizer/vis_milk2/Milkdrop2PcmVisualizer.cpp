//
// =================================================================
//
// BeatDrop/Milkwave - A Milkdrop2 Music Visualizer
//
// Authors : Maxim Volskiy (https://github.com/mvsoft74/BeatDrop) et al.
//
// From the readme :
// BeatDrop is a stand - alone implementation of the amazing Milkdrop2 Winamp plug-in.
// It lets you experience the stunning visual 2D effects with your music player of choice.
// No additional configuration steps needed!Just start BeatDrop and play your music.
// Use BeatDrop with your favourite Music player.
//
// The concept is realized by using audio loopback capture by Matthew van Eerde
// https://github.com/mvaneerde/blog
//
// =================================================================
//
//	                  Modified for Spout output
//
//                https://github.com/leadedge/BeatDrop
//
//					      Lynn Jarvis 2018-2023
//
//                       http://spout.zeal.co/
//
// Spout output can be imported into any host program with Spout support
// or by using the SpoutReceiver FreeframeGL plugin for Freeframe hosts.
// The visuals will then react to audio generated by the host itself.
// Search for "SPOUT" to find code changes.
//
//	Key functions changed slightly :
//
//  ESC  exit help / menus
//
//  F1   help
//  F4   preset name
//  F5   frames per second
//  F6   preset rating
//  F8   change preset folder
//	F9   toggle max fps 60/30
//  F12  show / hide render window
//
//  PRESET BROWSING :
//  SPACE     soft transition to next preset
//  H         instant hard cut to next preset
//  BACKSPACE go back to previous preset
//  ` or ~lock / unlock current preset
//  R         toggle random / sequential preset order
//  L         load specific preset
//  + / -rate current preset(better / worse)
//
//  PRESET EDITING AND SAVING
//  M    show / hide preset - editing Menu
//  S    save new preset
//  A    do random mini - mash - up
//  D    toggle warp & comp shader locks
//
// Revisons : see plugin.cpp
// NOTE : The device must be D3D9ex and not D3D9.
// See : void InitD3d(HWND hwnd, int width, int height)
// Changes throughout. Search for "DX9EX".
// Credit : Patrick Pomerleau - NEST Immersion.
//
// =================================================================
//
// Licencing :
//
// BeatDrop Copyright (c) 2018 Maxim Volskiy and individual contributors
// licenced with the 3-Clause BSD License (https://opensource.org/licenses/BSD-3-Clause) 
// with the exception of where otherwise noted.
//
// Original MilkDrop code by Ryan Geiss and Rovastar (John Baker)
// https://sourceforge.net/projects/milkdrop2/
//
// =================================================================
//
// Spout modifications : Copyright(C) 2018-2023, Lynn Jarvis. All rights reserved.
//
// licenced with 3-Clause BSD License.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met :
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors
// may be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"	AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE	ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// =================================================================

#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

// Define VK_B if it is not already defined
#ifndef VK_B
#define VK_B 0x42 // ASCII code for 'B'
#endif

// Define VK_C if it is not already defined
#ifndef VK_C
#define VK_C 0x43 // ASCII code for 'C'
#endif

#ifndef VK_D
#define VK_D 0x44 // ASCII code for 'D'
#endif

#ifndef VK_M
#define VK_M 0x4D // ASCII code for 'M'
#endif

#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>

#include <windows.h>
#include <process.h>
#include <d3d9.h>
#include <math.h>
#include <dwmapi.h>

#include <ShellScalingApi.h> // for dpi awareness
#pragma comment(lib, "shcore.lib") // for dpi awareness
// older Windows versions: Entry Point Not Found Fix

#include "plugin.h"
#include "resource.h"
#include "pluginshell.h"

#include <mutex>
#include <atomic>

//#include <core/sdk/constants.h>
//#include <core/sdk/IPcmVisualizer.h>
//#include <core/sdk/IPlaybackRemote.h>

#include "..\audio\common.h"
#include "milkwave.h"
#include <locale>
#include <codecvt>
#include "Milkdrop2PcmVisualizer.h"

namespace fs = std::filesystem;

#define DLL_EXPORT __declspec(dllexport)
//#define COMPILE_AS_DLL
#define SAMPLE_SIZE 576
#define DEFAULT_WIDTH 720;
#define DEFAULT_HEIGHT 720;

CPlugin g_plugin;
Milkwave milkwave;
HINSTANCE api_orig_hinstance = nullptr;
_locale_t g_use_C_locale;
char keyMappings[8];

// SPOUT
// ===============================================
static int nBeatDrops = 0; // Number of BeatDrop instances already running
BOOL CALLBACK GetWindowNames(HWND h, LPARAM l); // Window enumerator callback
// ===============================================

// SPOUT - DX9EX
static IDirect3D9Ex* pD3D9 = nullptr;
static IDirect3DDevice9Ex* pD3DDevice = nullptr;

static LONG lastWindowStyle = 0;
static LONG lastWindowStyleEx = 0;

static bool fullscreen = false;
static bool stretch = false;
static bool borderless = false;
static bool clickthrough = false;
static RECT lastRect = { 0 };

static HMODULE module = nullptr;
static std::atomic<HANDLE> threadRender = nullptr;
static std::atomic<HANDLE> threadSetup = nullptr;
static unsigned threadId = 0;
static std::mutex pcmMutex;
static unsigned char pcmLeftIn[SAMPLE_SIZE];
static unsigned char pcmRightIn[SAMPLE_SIZE];
static unsigned char pcmLeftOut[SAMPLE_SIZE];
static unsigned char pcmRightOut[SAMPLE_SIZE];

wchar_t m_szAudioDevice[MAX_PATH];
wchar_t m_szAudioDevicePrevious[MAX_PATH];

HANDLE hThreadLoopbackCapture;

bool pauseRender = false;

static HICON icon = nullptr;


// SPOUT
// ===============================================
BOOL CALLBACK GetWindowNames(HWND h, LPARAM l) {
  if (h == NULL)
    return FALSE;

  char search_window_name[MAX_PATH];

  if (IsWindow(h) && IsWindowVisible(h)) {
    GetWindowTextA(h, search_window_name, MAX_PATH);
    if (search_window_name[0]) {
      // Does the search window name contain "Milkwave Visualizer" ?
      if (strstr(search_window_name, "Milkwave Visualizer") != NULL) {
        nBeatDrops++;
      }
    }
  }
  return TRUE;
}
// ===============================================

// SPOUT - DX9EX
void InitD3d(HWND hwnd, int width, int height) {

  HRESULT Hr = Direct3DCreate9Ex(D3D_SDK_VERSION, &pD3D9);
  if (Hr != S_OK) {
    printf("Milkdrop2PcmVisualizer::InitD3d - Direct3DCreate9Ex error\n");
    return;
  }

  D3DCAPS9 d3dCaps;

  D3DDISPLAYMODEEX mode;
  D3DDISPLAYROTATION rot;
  pD3D9->GetAdapterDisplayModeEx(D3DADAPTER_DEFAULT, &mode, &rot);

  UINT adapterId = g_plugin.m_adapterId;

  if (adapterId > pD3D9->GetAdapterCount()) {
    adapterId = D3DADAPTER_DEFAULT;
  }

  memset(&g_plugin.d3dPp, 0, sizeof(g_plugin.d3dPp));

  g_plugin.d3dPp.BackBufferCount = 1;
  g_plugin.d3dPp.BackBufferFormat = D3DFMT_UNKNOWN;// mode.Format;

  if (g_plugin.IsSpoutActiveAndFixed()) {
    g_plugin.d3dPp.BackBufferWidth = width;
    g_plugin.d3dPp.BackBufferHeight = height;
  }
  else {
    g_plugin.SetVariableBackBuffer(width, height);
  }

  g_plugin.d3dPp.SwapEffect = D3DSWAPEFFECT_COPY;
  g_plugin.d3dPp.Flags = 0;
  g_plugin.d3dPp.EnableAutoDepthStencil = FALSE;// TRUE;
  g_plugin.d3dPp.AutoDepthStencilFormat = D3DFMT_D24S8;// D3DFMT_D24X8;
  g_plugin.d3dPp.Windowed = TRUE;
  g_plugin.d3dPp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
  g_plugin.d3dPp.MultiSampleType = D3DMULTISAMPLE_NONE;
  g_plugin.d3dPp.hDeviceWindow = (HWND)hwnd;

  // Test for hardware vertex processing capability and set up as needed
  // D3DCREATE_MULTITHREADED required by interop spec
  if (pD3D9->GetDeviceCaps(adapterId, D3DDEVTYPE_HAL, &d3dCaps) != S_OK) {
    printf("Milkdrop2PcmVisualizer::CreateDX9device - GetDeviceCaps error\n");
    return;
  }

  DWORD dwBehaviorFlags = D3DCREATE_PUREDEVICE | D3DCREATE_MULTITHREADED;
  if (d3dCaps.VertexProcessingCaps != 0)
    dwBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
  else
    dwBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

  Hr = pD3D9->CreateDeviceEx(
    adapterId,
    D3DDEVTYPE_HAL,
    (HWND)hwnd,
    dwBehaviorFlags,
    &g_plugin.d3dPp,
    NULL,
    &pD3DDevice);
}

void DeinitD3d() {
  if (pD3DDevice) {
    __try {
      pD3DDevice->Release();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
      wchar_t msg[256];
      swprintf_s(msg, L"DeinitD3d - Exception during device Release (0x%X)", GetExceptionCode());
      milkwave.LogInfo(msg);
    }
    pD3DDevice = nullptr;
  }

  if (pD3D9) {
    __try {
      pD3D9->Release();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
      wchar_t msg[256];
      swprintf_s(msg, L"DeinitD3d - Exception during D3D9 Release (0x%X)", GetExceptionCode());
      milkwave.LogInfo(msg);
    }
    pD3D9 = nullptr;
  }
}

//Multiple monitor stretch - Credit to @milkdropper for the code!
void ToggleStretch(HWND hwnd) {
  if (!stretch) {
    ShowCursor(FALSE);
    int width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    int left = GetSystemMetrics(SM_XVIRTUALSCREEN);
    int top = GetSystemMetrics(SM_YVIRTUALSCREEN);

    if (!fullscreen) {
      lastWindowStyle = GetWindowLong(hwnd, GWL_STYLE);
      lastWindowStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
      lastWindowStyleEx &= ~WS_EX_TOPMOST;
      GetWindowRect(hwnd, &lastRect);
    }

    g_plugin.SetVariableBackBuffer(width, height);
    pD3DDevice->Reset(&g_plugin.d3dPp);

    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
    SetWindowLongW(hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);
    SetWindowPos(hwnd, HWND_NOTOPMOST, left, top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    DragAcceptFiles(hwnd, TRUE);

    stretch = true;
  }
  else {
    ShowCursor(TRUE);

    int x = lastRect.left;
    int y = lastRect.top;
    int width = lastRect.right - lastRect.left;
    int height = lastRect.bottom - lastRect.top;

    g_plugin.SetVariableBackBuffer(width, height);
    pD3DDevice->Reset(&g_plugin.d3dPp);

    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    stretch = false;

    SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
    SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
    SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
    if (borderless) {
      SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
      SetWindowPos(hwnd, HWND_TOPMOST, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }
  }
  fullscreen = false;
}

static void ToggleClickThrough(HWND hWnd) {
  try {


    // Retrieve the current alpha value
    BYTE currentAlpha = 255; // Default to fully opaque
    DWORD flags = 0;
    COLORREF colorKey = 0;
    if (GetLayeredWindowAttributes(hWnd, &colorKey, &currentAlpha, &flags)) {
      // Successfully retrieved the current alpha value
    }

    if (clickthrough) {
      // Make the window normal while retaining WS_EX_LAYERED
      LONG_PTR style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
      style &= ~WS_EX_TRANSPARENT; // Remove click-through
      SetWindowLongPtr(hWnd, GWL_EXSTYLE, style);
      SetLayeredWindowAttributes(hWnd, 0, currentAlpha, LWA_ALPHA);
    }
    else {
      // Make the window click-through
      LONG_PTR style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
      style |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
      SetWindowLongPtr(hWnd, GWL_EXSTYLE, style);
      SetLayeredWindowAttributes(hWnd, 0, currentAlpha, LWA_ALPHA);
    }
    clickthrough = !clickthrough;
  } catch (const std::exception& e) {
    milkwave.LogException(L"ToggleClickThrough", e, true);
  }
}

static void ToggleBorderlessFullscreen(HWND hWnd) {
  try {
    static bool previousClickthrough = false; // Store the previous clickthrough state
    static float previousOpacity = 1.0f; // Store the previous opacity (fully opaque by default)

    // Check if Shift is pressed
    bool isShiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;

    // Get the work area of the monitor (excluding the taskbar)
    MONITORINFO monitorInfo = { sizeof(MONITORINFO) };
    HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);
    if (GetMonitorInfo(hMonitor, &monitorInfo)) {
      RECT workArea = monitorInfo.rcWork;

      // Check if the window is already in borderless fullscreen mode
      RECT currentRect;
      GetWindowRect(hWnd, &currentRect);

      if (currentRect.left == workArea.left &&
        currentRect.top == workArea.top &&
        currentRect.right == workArea.right &&
        currentRect.bottom == workArea.bottom) {
        // window appears to be borderless fullscreen
        // Restore the previous window dimensions, borderless state, clickthrough state, and opacity
        LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
        if (g_plugin.m_WindowBorderless) {
          style = WS_POPUP | WS_VISIBLE; // Restore borderless style
        }
        else {
          style = WS_OVERLAPPEDWINDOW | WS_VISIBLE; // Restore normal window style
        }
        SetWindowLongPtr(hWnd, GWL_STYLE, style);

        // Check if the saved dimensions are the same as the current dimensions
        if (g_plugin.m_WindowWidth == (currentRect.right - currentRect.left) &&
          g_plugin.m_WindowHeight == (currentRect.bottom - currentRect.top)) {
          // Reduce the dimensions by 50%
          g_plugin.m_WindowWidth /= 2;
          g_plugin.m_WindowHeight /= 2;

          // Center the window
          g_plugin.m_WindowX = (workArea.right - workArea.left - g_plugin.m_WindowWidth) / 2;
          g_plugin.m_WindowY = (workArea.bottom - workArea.top - g_plugin.m_WindowHeight) / 2;
        }

        SetWindowPos(
          hWnd,
          g_plugin.m_WindowBorderless ? HWND_TOPMOST : HWND_NOTOPMOST,
          g_plugin.m_WindowX,
          g_plugin.m_WindowY,
          g_plugin.m_WindowWidth,
          g_plugin.m_WindowHeight,
          SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE
        );

        // Restore the previous clickthrough state
        if (clickthrough != previousClickthrough) {
          ToggleClickThrough(hWnd);
        }

        if (g_plugin.fOpacity != previousOpacity) {
          g_plugin.fOpacity = previousOpacity;
          g_plugin.SetOpacity(hWnd);
        }

        // Restore the previous opacity
        // SetLayeredWindowAttributes(hWnd, 0, previousOpacity, LWA_ALPHA);

        borderless = g_plugin.m_WindowBorderless; // Restore the borderless state
        fullscreen = false;
      }
      else {
        // not in borderless fullscreen mode, so toggle to it
        // Save the current window dimensions, borderless state, clickthrough state, and opacity
        RECT currentWindowRect;
        GetWindowRect(hWnd, &currentWindowRect);
        g_plugin.m_WindowX = currentWindowRect.left;
        g_plugin.m_WindowY = currentWindowRect.top;
        g_plugin.m_WindowWidth = currentWindowRect.right - currentWindowRect.left;
        g_plugin.m_WindowHeight = currentWindowRect.bottom - currentWindowRect.top;
        g_plugin.m_WindowBorderless = borderless; // Save the current borderless state

        previousClickthrough = clickthrough; // Save the current clickthrough state
        previousOpacity = g_plugin.fOpacity;

        // Set the window style to borderless
        LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
        style &= ~(WS_OVERLAPPEDWINDOW); // Remove standard window styles
        style |= WS_POPUP; // Add popup style for borderless
        SetWindowLongPtr(hWnd, GWL_STYLE, style);

        // Set the window position and size to fit the work area
        SetWindowPos(
          hWnd,
          isShiftPressed ? HWND_TOPMOST : HWND_NOTOPMOST,
          workArea.left,
          workArea.top,
          workArea.right - workArea.left,
          workArea.bottom - workArea.top,
          SWP_FRAMECHANGED | SWP_NOACTIVATE
        );

        // If Shift is pressed, enable clickthrough
        if (isShiftPressed) {
          if (!clickthrough) {
            ToggleClickThrough(hWnd);
          }
          g_plugin.fOpacity = g_plugin.m_WindowWatermarkModeOpacity;
          g_plugin.SetOpacity(hWnd);
          //SetLayeredWindowAttributes(hWnd, 0, (BYTE)(g_plugin.m_WindowWatermarkModeOpacity * 255), LWA_ALPHA);
        }

        g_plugin.m_bAlwaysOnTop = isShiftPressed; // Set always on top based on Shift key state
        borderless = true;
      }
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"ToggleBorderlessFullscreen", e, true);
  }
}

static void ToggleFullScreen(HWND hwnd) {
  if (g_plugin.IsBorderlessFullscreen(hwnd)) {
    // ShowCursor(TRUE);
    ToggleBorderlessFullscreen(hwnd);
  }
  else if (!fullscreen) {
    ShowCursor(FALSE);

    if (!stretch) {
      lastWindowStyle = GetWindowLong(hwnd, GWL_STYLE);
      lastWindowStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
      lastWindowStyleEx &= ~WS_EX_TOPMOST;
      GetWindowRect(hwnd, &lastRect);
    }

    HMONITOR monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);

    MONITORINFO info;
    info.cbSize = sizeof(MONITORINFO);

    GetMonitorInfoW(monitor, &info);

    int width = info.rcMonitor.right - info.rcMonitor.left;
    int height = info.rcMonitor.bottom - info.rcMonitor.top;

    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
    SetWindowLongW(hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);
    SetWindowPos(hwnd, HWND_TOPMOST, info.rcMonitor.left, info.rcMonitor.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);

    g_plugin.SetVariableBackBuffer(width, height);
    HRESULT hr = pD3DDevice->Reset(&g_plugin.d3dPp);
    if (FAILED(hr)) {
      switch (hr) {
      case D3DERR_DEVICELOST:
        // Device is lost, cannot reset now. Retry later.
        g_plugin.AddError(L"Direct3D device is lost, retry later", 5.0f, ERR_NOTIFY, false);
        break;

      case D3DERR_DEVICENOTRESET:
        // Device is ready to be reset but failed. Consider releasing resources.
        g_plugin.AddError(L"Direct3D device could not be reset, releasing resources", 5.0f, ERR_NOTIFY, false);
        // Add code to release and recreate resources if necessary.
        break;

      case D3DERR_OUTOFVIDEOMEMORY:
        // Out of video memory.
        g_plugin.AddError(L"Out of video memory - Reduce resource usage", 5.0f, ERR_NOTIFY, false);
        break;

      case E_OUTOFMEMORY:
        // General memory allocation failure.
        g_plugin.AddError(L"Out of memory - Unable to reset device", 5.0f, ERR_NOTIFY, false);
        break;

      default:
        // Unknown error.
        wchar_t buf[256];
        swprintf(buf, 256, L"Unknown error during Reset: 0x%08X", hr);
        g_plugin.AddError(buf, 5.0f, ERR_NOTIFY, false);
        break;
      }

      // Optional: Fallback to windowed mode or attempt recovery.
      fullscreen = false;
      SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
      SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
      SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top,
        lastRect.right - lastRect.left, lastRect.bottom - lastRect.top,
        SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }

    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    DragAcceptFiles(hwnd, TRUE);
    fullscreen = true;
  }
  else {
    ShowCursor(TRUE);

    int x = lastRect.left;
    int y = lastRect.top;
    int width = lastRect.right - lastRect.left;
    int height = lastRect.bottom - lastRect.top;

    g_plugin.SetVariableBackBuffer(width, height);
    pD3DDevice->Reset(&g_plugin.d3dPp);

    SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);
    fullscreen = false;

    SetWindowLongW(hwnd, GWL_STYLE, lastWindowStyle);
    SetWindowLongW(hwnd, GWL_EXSTYLE, lastWindowStyleEx);
    SetWindowPos(hwnd, HWND_NOTOPMOST, lastRect.left, lastRect.top, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
    if (borderless) {
      SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
      SetWindowPos(hwnd, HWND_TOPMOST, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    }
  }
  stretch = false;
}

void SetWindowFixedDimensions(HWND hwnd) {
  int windowX = 0;
  int windowY = 0;

  RECT rect;
  if (GetWindowRect(hwnd, &rect)) {
    windowX = rect.left;
    windowY = rect.top;
  }

  // Restore the window to a normal state if minimized or maximized
  ShowWindow(hwnd, SW_RESTORE);

  // Adjust the window size and position
  SetWindowPos(hwnd, HWND_NOTOPMOST, windowX, windowY, g_plugin.m_WindowFixedWidth, g_plugin.m_WindowFixedHeight, SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE);
}

void ResetWindow(HWND hwnd) {
  // Get the screen dimensions
  int screenWidth = GetSystemMetrics(SM_CXSCREEN);
  int screenHeight = GetSystemMetrics(SM_CYSCREEN);

  int windowWidth = screenWidth / 3;
  int windowHeight = screenHeight / 3;

  int windowX = screenWidth - windowWidth - windowWidth / 4;
  int windowY = windowHeight / 4;

  // Restore the window to a normal state if minimized or maximized
  ShowWindow(hwnd, SW_RESTORE);

  // Remove any transparency or click-through flags
  LONG_PTR exStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
  exStyle &= ~(WS_EX_LAYERED | WS_EX_TRANSPARENT); // Remove transparency and click-through
  SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle);

  // Reset the window style to a standard overlapped window
  SetWindowLongW(hwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

  // Adjust the window size and position
  SetWindowPos(hwnd, HWND_NOTOPMOST, windowX, windowY, windowWidth, windowHeight, SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE);

  // Ensure the window is fully opaque
  SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);

  g_plugin.fOpacity = 1.0f;
  g_plugin.m_WindowBorderless = false;
  borderless = false;
  clickthrough = false;
  fullscreen = false;
}

static void ToggleBorderlessWindow(HWND hwnd) {
  static RECT lastRect = { 0 }; // Store the previous window position and size
  GetWindowRect(hwnd, &lastRect);
  int x = lastRect.left;
  int y = lastRect.top;
  int width = lastRect.right - lastRect.left;
  int height = lastRect.bottom - lastRect.top;
  GetWindowRect(hwnd, &lastRect);

  static bool wasTransparent = false; // Track if the window was transparent before toggling

  // Check if the window currently has transparency
  BYTE currentAlpha = 255; // Default to fully opaque
  DWORD flags = 0;
  COLORREF colorKey = 0;
  if (GetLayeredWindowAttributes(hwnd, &colorKey, &currentAlpha, &flags)) {
    wasTransparent = (flags & LWA_COLORKEY) != 0; // Check if LWA_COLORKEY is set
  }

  // --- Preserve current topmost state ---
  // Determine if the window is currently topmost
  HWND hInsertAfter = HWND_NOTOPMOST;
  // WS_EX_TOPMOST is 0x00000008L
  LONG_PTR exStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
  if (exStyle & WS_EX_TOPMOST) {
    hInsertAfter = HWND_TOPMOST;
  }

  if (!borderless) {
    // Save the current window position and size

    // Set the window style to borderless
    SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);

    // Reapply transparency only if it was present before
    if (wasTransparent) {
      SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 255, LWA_COLORKEY);
    }

    SetWindowPos(hwnd, hInsertAfter, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    borderless = true;
  }
  else {
    // Restore the previous window style and position
    SetWindowLongW(hwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

    // Reapply transparency only if it was present before
    if (wasTransparent) {
      SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 255, LWA_COLORKEY);
    }

    SetWindowPos(hwnd, hInsertAfter, x, y, width, height, SWP_DRAWFRAME | SWP_FRAMECHANGED);
    borderless = false;
  }
  g_plugin.m_WindowBorderless = borderless;
}


HRESULT GetDefaultAudioDeviceName(IMMDevice** ppMMDevice, std::wstring* m_szAudioDeviceDisplayName) {
  HRESULT hr = S_OK;
  IMMDeviceEnumerator* pMMDeviceEnumerator;

  // activate a device enumerator
  hr = CoCreateInstance(
    __uuidof(MMDeviceEnumerator), NULL, CLSCTX_ALL,
    __uuidof(IMMDeviceEnumerator),
    (void**)&pMMDeviceEnumerator
  );
  if (FAILED(hr)) {
    ERR(L"CoCreateInstance(IMMDeviceEnumerator) failed: hr = 0x%08x", hr);
    return hr;
  }
  ReleaseOnExit releaseMMDeviceEnumerator(pMMDeviceEnumerator);

  // get the default render endpoint
  hr = pMMDeviceEnumerator->GetDefaultAudioEndpoint(eRender, eConsole, ppMMDevice);
  if (FAILED(hr)) {
    ERR(L"IMMDeviceEnumerator::GetDefaultAudioEndpoint failed: hr = 0x%08x", hr);
    return hr;
  }

  // open the property store on that device
  IPropertyStore* pPropertyStore;
  hr = (*ppMMDevice)->OpenPropertyStore(STGM_READ, &pPropertyStore);
  if (FAILED(hr)) {
    ERR(L"IMMDevice::OpenPropertyStore failed: hr = 0x%08x", hr);
    return hr;
  }
  ReleaseOnExit releasePropertyStore(pPropertyStore);

  // get the long name property
  PROPVARIANT pv; PropVariantInit(&pv);
  hr = pPropertyStore->GetValue(PKEY_Device_FriendlyName, &pv);
  if (FAILED(hr)) {
    ERR(L"IPropertyStore::GetValue failed: hr = 0x%08x", hr);
    return hr;
  }
  PropVariantClearOnExit clearPv(&pv);

  if (VT_LPWSTR != pv.vt) {
    ERR(L"PKEY_Device_FriendlyName variant type is %u - expected VT_LPWSTR", pv.vt);
    return E_UNEXPECTED;
  }
  *m_szAudioDeviceDisplayName = std::wstring(pv.pwszVal);

  return S_OK;
}

LRESULT CALLBACK StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

  static bool rightMouseButtonHeld = false; // Track the state of the right mouse button  

  switch (uMsg) {
  case WM_CLOSE:
  {
    g_plugin.SaveWindowSizeAndPosition(hWnd);
    DestroyWindow(hWnd);
    UnregisterClassW(L"Direct3DWindowClass", NULL);
    return 0;
  }

  case WM_DESTROY:
  {
    PostQuitMessage(0);
    break;
  }

  case WM_MOVE:
  {
    // Get the current window rectangle
    RECT windowRect;
    GetWindowRect(hWnd, &windowRect);

    // Get the virtual screen area (spanning all monitors)
    int virtualLeft = GetSystemMetrics(SM_XVIRTUALSCREEN);
    int virtualTop = GetSystemMetrics(SM_YVIRTUALSCREEN);
    int virtualWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int virtualHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    int virtualRight = virtualLeft + virtualWidth;
    int virtualBottom = virtualTop + virtualHeight;

    int windowWidth = windowRect.right - windowRect.left;
    int windowHeight = windowRect.bottom - windowRect.top;

    // Constrain the window to stay within the virtual screen area
    int newX = windowRect.left;
    int newY = windowRect.top;

    if (newX < virtualLeft) {
      newX = virtualLeft;
    }
    if (newY < virtualTop) {
      newY = virtualTop;
    }
    if (newX + windowWidth > virtualRight) {
      newX = virtualRight - windowWidth;
    }
    if (newY + windowHeight > virtualBottom) {
      newY = virtualBottom - windowHeight;
    }

    // Set the new position if adjustments were made
    if (newX != windowRect.left || newY != windowRect.top) {
      SetWindowPos(hWnd, NULL, newX, newY, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    break;
  }

  case WM_KEYDOWN:
  {
    g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
  }
  if (wParam == VK_F2) {
    bool isCtrlPressed = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (isCtrlPressed) {
      bool isShiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
      if (isShiftPressed) {
        SetWindowFixedDimensions(hWnd);
      }
      else {
        ResetWindow(hWnd);
      }
    }
    else if (!fullscreen && !stretch) {
      ToggleBorderlessWindow(hWnd);
    }
  }
  if (wParam == VK_F9) {
    bool isCtrlPressed = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (isCtrlPressed) {
      ToggleBorderlessFullscreen(hWnd);
    }
    else {
      ToggleClickThrough(hWnd);
      if (clickthrough) {
        g_plugin.AddNotification(L"Clickthrough Mode enabled");
      }
      else {
        g_plugin.AddNotification(L"Clickthrough Mode disabled");
      }
    }
  }
  else if (wParam == VK_B) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.m_SongInfoPollingEnabled = !g_plugin.m_SongInfoPollingEnabled;
      milkwave.doPoll = g_plugin.m_SongInfoPollingEnabled;
      if (g_plugin.m_SongInfoPollingEnabled) {
        g_plugin.AddNotification(L"Song Info enabled");
      }
      else {
        g_plugin.AddNotification(L"Song Info disabled");
        milkwave.currentArtist = L"";
        milkwave.currentTitle = L"";
        milkwave.currentAlbum = L"";
      }
    }
    else {
      milkwave.doPollExplicit = true;
    }
    return 0;
  }
  else if (wParam == VK_C) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.m_DisplayCover = !g_plugin.m_DisplayCover;
      milkwave.doSaveCover = g_plugin.m_DisplayCover;
      if (g_plugin.m_DisplayCover) {
        g_plugin.AddNotification(L"Cover Display enabled");
      }
      else {
        g_plugin.AddNotification(L"Cover Display disabled");
      }
    }
    else {
      milkwave.doPollExplicit = true;
    }
    return 0;
  }
  else if (wParam == VK_D) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      bool isShiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
      if (isShiftPressed) {
        g_plugin.AddNotification(g_plugin.m_szAudioDeviceDisplayName);
      }
      else {
        wcscpy_s(g_plugin.m_szAudioDevicePrevious, g_plugin.m_szAudioDevice);
        g_plugin.m_nAudioDevicePreviousType = g_plugin.m_nAudioDeviceActiveType;

        IMMDevice* m_pMMDevice;
        std::wstring sAudioDeviceDisplayName;
        GetDefaultAudioDeviceName(&m_pMMDevice, &sAudioDeviceDisplayName);
        wcscpy(g_plugin.m_szAudioDevice, sAudioDeviceDisplayName.c_str());

        g_plugin.SetAudioDeviceDisplayName(sAudioDeviceDisplayName.c_str(), true);

        // Restart audio
        g_plugin.m_nAudioDeviceRequestType = 2;
        g_plugin.m_nAudioLoopState = 1;
      }
    }
    return 0;
  }
  else if (wParam == VK_M) {
    if (GetKeyState(VK_CONTROL) & 0x8000) { // Check if Ctrl is pressed
      g_plugin.m_bEnableMouseInteraction = !g_plugin.m_bEnableMouseInteraction;
      if (g_plugin.m_bEnableMouseInteraction) {
        g_plugin.AddNotification(L"Mouse interaction enabled");
      }
      else {
        g_plugin.AddNotification(L"Mouse interaction disabled");
      }
    }
  }

  case WM_NCHITTEST: //used for borderless window
  {
    // if (borderless)
    if (!fullscreen && !stretch) {
      // resizable borderless
      // from https://stackoverflow.com/questions/19106047/winapi-c-reprogramming-window-resize
#define BORDERWIDTH  10
#define TITLEBARWIDTH  30
      RECT rect;
      int x, y;
      GetWindowRect(hWnd, &rect);

      x = GET_X_LPARAM(lParam) - rect.left;
      y = GET_Y_LPARAM(lParam) - rect.top;

      // When mouse interaction is enabled, let the plugin handle client-area mouse events.
      // Still allow resizing by returning the correct HT* edge codes for the border zones.
      if (g_plugin.m_bEnableMouseInteraction && !(GetAsyncKeyState(VK_LBUTTON) & 0x8000)) {
        if (x < BORDERWIDTH && y < BORDERWIDTH)
          return HTTOPLEFT;
        else if (x > rect.right - rect.left - BORDERWIDTH && y < BORDERWIDTH)
          return HTTOPRIGHT;
        else if (x > rect.right - rect.left - BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
          return HTBOTTOMRIGHT;
        else if (x < BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
          return HTBOTTOMLEFT;
        else if (x < BORDERWIDTH)
          return HTLEFT;
        else if (y < BORDERWIDTH)
          return HTTOP;
        else if (x > rect.right - rect.left - BORDERWIDTH)
          return HTRIGHT;
        else if (y > rect.bottom - rect.top - BORDERWIDTH)
          return HTBOTTOM;

        // interior -> client area (so MyWindowProc receives mouse messages)
        return HTCLIENT;
      }

      // Default (existing) behavior when mouse interaction is disabled:
      if (x >= BORDERWIDTH && x <= rect.right - rect.left - BORDERWIDTH && y >= BORDERWIDTH && y <= TITLEBARWIDTH)
        return HTCAPTION;

      else if (x < BORDERWIDTH && y < BORDERWIDTH)
        return HTTOPLEFT;
      else if (x > rect.right - rect.left - BORDERWIDTH && y < BORDERWIDTH)
        return HTTOPRIGHT;
      else if (x > rect.right - rect.left - BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOMRIGHT;
      else if (x < BORDERWIDTH && y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOMLEFT;

      else if (x < BORDERWIDTH)
        return HTLEFT;
      else if (y < BORDERWIDTH)
        return HTTOP;
      else if (x > rect.right - rect.left - BORDERWIDTH)
        return HTRIGHT;
      else if (y > rect.bottom - rect.top - BORDERWIDTH)
        return HTBOTTOM;
      return HTCAPTION;
    }
    break;
  }

  case WM_NCLBUTTONDBLCLK:
  {
    if (fullscreen) {
      ToggleFullScreen(hWnd);
      return 0;
    }

    bool ctrlHeld = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (ctrlHeld) {
      ToggleBorderlessWindow(hWnd);
      return 0;
    }

    ToggleFullScreen(hWnd);
    return 0;
  }

  case WM_NCRBUTTONDBLCLK:
  {
    ToggleBorderlessWindow(hWnd);
    break;
  }

  case WM_SYSKEYDOWN:
  {
    if (wParam == VK_F4) { // SPOUT ??
      PostQuitMessage(0);
    }
    else if (wParam == 'S' || wParam == 's') {
      ToggleStretch(hWnd);
    }
    else if (wParam == VK_RETURN) {
      ToggleFullScreen(hWnd);
    }
    else {
      g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    break;
  }

  case WM_RBUTTONDOWN:
  case WM_NCRBUTTONDOWN: // Right mouse button pressed
    // If plugin-level mouse interaction is enabled, let the plugin handle the event.
    rightMouseButtonHeld = true;
    if (g_plugin.m_bEnableMouseInteraction) {
      return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    break;

  case WM_RBUTTONUP:
  case WM_NCRBUTTONUP: // Right mouse button released
    rightMouseButtonHeld = false;
    if (g_plugin.m_bEnableMouseInteraction) {
      return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    break;

  case WM_LBUTTONDOWN:
  case WM_NCLBUTTONDOWN: // Left mouse button pressed
    if (rightMouseButtonHeld) {
      // Right + Left
      PostMessage(hWnd, WM_CLOSE, 0, 0); // Close the window
    }
    else {
      return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    break;

  case WM_LBUTTONUP:
  case WM_NCLBUTTONUP: // Left mouse button released
    //if (g_plugin.m_bEnableMouseInteraction) {
    return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    //}
    // no special action on left button up in existing logic
    break;

  case WM_MBUTTONDOWN:
  case WM_NCMBUTTONDOWN: // Middle mouse button clicked
    if (rightMouseButtonHeld) {
      // Right + Middle
      g_plugin.OpenMilkwaveRemote();
    }
    else {
      // Middle only
      milkwave.doPollExplicit = true;
    }
    break;

  case WM_LBUTTONDBLCLK:
  {
    // If we're currently fullscreen, always exit fullscreen on a left-button double-click
    // anywhere in the client area (there is no title bar in fullscreen).
    if (fullscreen) {
      ToggleFullScreen(hWnd);
      return 0;
    }

    bool ctrlHeld = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    if (ctrlHeld) {
      ToggleBorderlessWindow(hWnd);
      return 0;
    }

    // Determine position relative to window
    RECT rect; GetWindowRect(hWnd, &rect);
    int y = GET_Y_LPARAM(lParam) - rect.top;
    bool inTitle = (y <= TITLEBARWIDTH);

    // If plugin mouse interaction is enabled and the dblclick is in client area,
    // let the plugin handle it. Otherwise toggle fullscreen.
    if (g_plugin.m_bEnableMouseInteraction && !inTitle) {
      return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }

    ToggleFullScreen(hWnd);
    return 0;
  }

  case WM_RBUTTONDBLCLK:
  {
    if (g_plugin.m_bEnableMouseInteraction) {
      return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
    }
    ToggleBorderlessWindow(hWnd);
    break;
  }

  default:
    return g_plugin.PluginShellWindowProc(hWnd, uMsg, wParam, lParam);
  }

  return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


void RenderFrame() {

  {
    std::unique_lock<std::mutex> lock(pcmMutex);
    memcpy(pcmLeftOut, pcmLeftIn, SAMPLE_SIZE);
    memcpy(pcmRightOut, pcmRightIn, SAMPLE_SIZE);
    memset(pcmLeftIn, 0, SAMPLE_SIZE);
    memset(pcmRightIn, 0, SAMPLE_SIZE);
  }

  milkwave.PollMediaInfo();
  if (milkwave.coverUpdated) {
    g_plugin.PostMessageToMilkwaveRemote(WM_USER_COVER_CHANGED);
    milkwave.coverUpdated = false;
  }
  if (milkwave.updated) {
    if (milkwave.isSongChange && !milkwave.doPollExplicit) {
      if (g_plugin.m_ChangePresetWithSong) {
        g_plugin.NextPreset(g_plugin.m_fBlendTimeAuto);
      }
      if (g_plugin.m_DisplayCover) {
        g_plugin.LaunchSprite(0, -1);
      }
    }

    if (milkwave.doPollExplicit && g_plugin.m_DisplayCoverWhenPressingB) {
      g_plugin.LaunchSprite(0, -1);
    }

    milkwave.doPollExplicit = false;
    wchar_t buf[512];

    // Convert wchar_t array to std::string
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    std::string format = converter.to_bytes(g_plugin.m_SongInfoFormat);
    std::istringstream stream(format);
    std::vector<std::string> tokens;
    std::string token;

    // Split the string into tokens
    while (std::getline(stream, token, ';')) {
      tokens.push_back(token);
    }

    // remove existing song info display
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_1);
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_2);
    g_plugin.ClearErrors(ERR_MSG_BOTTOM_EXTRA_3);

    // Iterate over tokens in reverse order
    for (auto it = tokens.rbegin(); it != tokens.rend(); ++it) {
      std::string currentToken = *it;

      // Convert token to lowercase for case-insensitive comparison
      std::transform(currentToken.begin(), currentToken.end(), currentToken.begin(), ::tolower);

      if (currentToken == "artist") {
        if (milkwave.currentArtist.length() > 0) {
          wcscpy(buf, milkwave.currentArtist.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_1, false);
        }
      }
      else if (currentToken == "title") {
        if (milkwave.currentTitle.length() > 0) {
          wcscpy(buf, milkwave.currentTitle.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_2, false);
        }
      }
      else if (currentToken == "album") {
        if (milkwave.currentAlbum.length() > 0) {
          wcscpy(buf, milkwave.currentAlbum.c_str());
          g_plugin.AddError(buf, g_plugin.m_SongInfoDisplaySeconds, ERR_MSG_BOTTOM_EXTRA_3, false);
        }
      }
    }

    milkwave.updated = false;
  }

  g_plugin.PluginRender(
    (unsigned char*)pcmLeftOut,
    (unsigned char*)pcmRightOut);

}

unsigned __stdcall CreateWindowAndRun(void* data) {

  HINSTANCE instance = (HINSTANCE)data;

#ifdef DEBUG
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
  _CrtSetBreakAlloc(60);
#endif

  // SPOUT
  // Set Per Monitor awareness
  SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE); //older Windows versions: Entry Point Not Found Fix
  // SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE);

  // Register the windows class
  WNDCLASSW wndClass;
  wndClass.style = CS_DBLCLKS;
  wndClass.lpfnWndProc = StaticWndProc;
  wndClass.cbClsExtra = 0;
  wndClass.cbWndExtra = 0;
  wndClass.hInstance = instance;
  wndClass.hIcon = LoadIconW(instance, MAKEINTRESOURCEW(IDI_PLUGIN_ICON));
  wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
  wndClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
  wndClass.lpszMenuName = NULL;
  wndClass.lpszClassName = L"Direct3DWindowClass";

  if (!RegisterClassW(&wndClass)) {
    DWORD dwError = GetLastError();
    if (dwError != ERROR_CLASS_ALREADY_EXISTS) {
      return 0;
    }
  }

  // SPOUT
  // Make the window a fixed size
    // The sender resolution is independent - see SpoutWidth/SpoutHeight below
  int windowWidth = 1280; // standalone version 1280x720
  int windowHeight = 720;

  RECT rc;
  SetRect(&rc, 0, 0, windowWidth, windowHeight);
  AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, false);

  // SPOUT
  // Centre on the desktop work area
  int WindowPosLeft = 0;
  int WindowPosTop = 0;
  RECT WorkArea;
  SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
  WindowPosLeft += ((WorkArea.right - WorkArea.left) - windowWidth) / 2;
  WindowPosTop += ((WorkArea.bottom - WorkArea.top) - windowHeight) / 2;

  // SPOUT
  // Remove minimize and maximize
  //DWORD dwStyle = (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME);

  // ===============================================
  // Enumerate other instances of BeatDrop to increment the title
  WCHAR VisualizerWindowTitle[256];
  // printf("Number of existing BeatDrops (%d)\n", nBeatDrops);

  bool freeTitleFound = false;
  nBeatDrops = 0;

  while (!freeTitleFound && nBeatDrops < 100) {
    if (nBeatDrops == 0) {
      lstrcpyW(VisualizerWindowTitle, L"Milkwave Visualizer");
    }
    else {
      swprintf_s(VisualizerWindowTitle, L"Milkwave Visualizer %d", nBeatDrops + 1);
    }

    // Check if a window with this title already exists
    HWND existing = FindWindowW(L"Direct3DWindowClass", VisualizerWindowTitle);
    if (existing != NULL) {
      nBeatDrops++;
      // Try next title
    }
    else {
      // No window with this title, so we can use it
      printf("New title [%S]\n", VisualizerWindowTitle);
      freeTitleFound = true;
    }
  }

  milkwave.LogInfo(L"CreateWindowAndRun: Creating window");

  if (g_plugin.m_WindowX == 0 || g_plugin.m_WindowY == 0 || g_plugin.m_WindowWidth == 0 || g_plugin.m_WindowHeight == 0) {
    RECT workArea{};
    if (!SystemParametersInfoW(SPI_GETWORKAREA, 0, &workArea, 0)) {
      workArea.left = 0;
      workArea.top = 0;
      workArea.right = GetSystemMetrics(SM_CXSCREEN);
      workArea.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    const int gapPx = 50;
    int spanWidth = workArea.right - workArea.left;
    int spanHeight = workArea.bottom - workArea.top;
    int defaultWidth = spanWidth > 0 ? spanWidth / 3 : 640;
    int defaultHeight = spanHeight > 0 ? spanHeight / 3 : 360;
    if (defaultWidth <= 0) {
      defaultWidth = 640;
    }
    if (defaultHeight <= 0) {
      defaultHeight = 360;
    }

    g_plugin.m_WindowWidth = defaultWidth;
    g_plugin.m_WindowHeight = defaultHeight;
    g_plugin.m_WindowX = (workArea.right - gapPx) - g_plugin.m_WindowWidth;
    g_plugin.m_WindowY = workArea.top + gapPx;
  }


  // Create the render window
  HWND hwnd = CreateWindowW(
    L"Direct3DWindowClass",
    VisualizerWindowTitle,
    WS_OVERLAPPEDWINDOW, // SPOUT
    //dwStyle,
    g_plugin.m_WindowX,
    g_plugin.m_WindowY,
    g_plugin.m_WindowWidth,
    g_plugin.m_WindowHeight,
    0,
    NULL,
    instance,
    0);

  if (!hwnd) {
    milkwave.LogInfo(L"CreateWindowAndRun: No window handle!");
    DWORD dwError = GetLastError();
    return 0;
  }

  if (!icon) {
    icon = LoadIconW(instance, MAKEINTRESOURCEW(IDI_PLUGIN_ICON));
  }

  SendMessageW(hwnd, WM_SETICON, ICON_BIG, (LPARAM)icon);
  SendMessageW(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)icon);

  // window was closed in borderless fullscreen mode
  if (g_plugin.IsBorderlessFullscreen(hwnd)) {
    g_plugin.fOpacity = g_plugin.m_WindowWatermarkModeOpacity;
    g_plugin.SetOpacity(hwnd);
    if (!clickthrough) ToggleClickThrough(hwnd);
    g_plugin.m_bAlwaysOnTop = true;
    g_plugin.ToggleAlwaysOnTop(hwnd);
  }
  else {
    if (g_plugin.fOpacity < 1) {
      g_plugin.SetOpacity(hwnd);
    }
  }

  if (IsWindow(hwnd)) {
    ShowWindow(hwnd, SW_SHOW);
  }
  else {
    milkwave.LogInfo(L"CreateWindowAndRun: ShowWindow failed, window not created");
  }

  if (g_plugin.m_bAlwaysOnTop) {
    g_plugin.ToggleAlwaysOnTop(hwnd);
  }
  if (g_plugin.m_WindowBorderless && !borderless) {
    ToggleBorderlessWindow(hwnd);
  }

  // always ensure .Init is called after the window is created (ShowWindow above)
  milkwave.Init(g_plugin.m_szBaseDir);
  milkwave.doPoll = g_plugin.m_SongInfoPollingEnabled;
  milkwave.doSaveCover = g_plugin.m_DisplayCover;

  unsigned int frame = 0;


  // Milkwave: Moved to StartThreads()
  // g_plugin.PluginPreInitialize(0, 0);

  // SPOUT

  unsigned int BackbufferWidth = g_plugin.m_WindowWidth;
  unsigned int BackbufferHeight = g_plugin.m_WindowHeight;
  if (g_plugin.IsSpoutActiveAndFixed()) {
    BackbufferWidth = g_plugin.nSpoutFixedWidth;
    BackbufferHeight = g_plugin.nSpoutFixedHeight;
  }

  milkwave.LogInfo(L"CreateWindowAndRun: InitD3d");
  InitD3d(hwnd, BackbufferWidth, BackbufferHeight);

  milkwave.LogInfo(L"CreateWindowAndRun: PluginInitialize");
  g_plugin.PluginInitialize(
    pD3DDevice,
    &g_plugin.d3dPp,
    hwnd,
    // windowWidth,
    // windowHeight);
    BackbufferWidth,
    BackbufferHeight);

  MSG msg;
  msg.message = WM_NULL;

  try {
    milkwave.LogInfo(L"CreateWindowAndRun: Message loop starting");

    PeekMessage(&msg, NULL, 0U, 0U, PM_NOREMOVE);
    while (WM_QUIT != msg.message) {
      try {
        if (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE) != 0) {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
        }
        else if (!pauseRender) {
          GetAudioBuf(pcmLeftIn, pcmRightIn, SAMPLE_SIZE);
          RenderFrame();
        }
      } catch (const std::exception& e) {
        try {
          // Convert exception message (UTF-8) to wide string for logging
          std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
          std::wstring emsg = converter.from_bytes(e.what());
          std::wstring logMsg = L"Exception in render loop: " + emsg;
          milkwave.LogInfo(logMsg);
        } catch (...) {
          milkwave.LogInfo(L"Exception in render loop (failed to convert exception message)");
        }
      } catch (...) {
        milkwave.LogInfo(L"Unknown non-standard exception in render loop");
      }
      frame++;
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"CreateWindowAndRun: Exception in main loop", e, true);
  }
  milkwave.LogInfo(L"CreateWindowAndRun: Message loop ended");

  g_plugin.MyWriteConfig();
  g_plugin.PluginQuit();

  DeinitD3d();

  threadRender = nullptr;
  threadId = 0;

  return 0;
}

void StartRenderThread(HINSTANCE instance) {
  threadRender = (HANDLE)_beginthreadex(
    nullptr,
    0,
    &CreateWindowAndRun,
    (void*)instance,
    0,
    &threadId);
}

static int StartAudioCaptureThread(HINSTANCE instance, int nestingLevel) {

  try {

    HRESULT hr = S_OK;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
      ERR(L"CoInitialize failed: hr = 0x%08x", hr);
      return -__LINE__;
    }
    CoUninitializeOnExit cuoe;

    // argc==1 No additional params. Output disabled.
    // argc==3 Two additional params. Output file enabled (32bit IEEE 754 FLOAT).
    // argc==4 Three additional params. Output file enabled (LITTLE ENDIAN PCM).
    int argc = 1;
    // LPCWSTR argv[4] = { L"", L"--file", L"loopback-capture.wav", L"--int-16" };
    LPCWSTR argv[4] = { L"", L"", L"", L"" };

    if (wcslen(g_plugin.m_szAudioDevice) > 0) {
      argc = 3;
      argv[1] = L"--device";
      argv[2] = g_plugin.m_szAudioDevice;
    };

    /*
    L"%ls [--device \"Device long name\"] [--file \"file name\"] [--int-16]\n"
      L"\n"
      L"    -? prints this message.\n"
      L"    --list-devices displays the long names of all active playback devices.\n"
      L"    --device captures from the specified device (default if omitted)\n"
      L"    --file saves the output to a file (%ls if omitted)\n"
      L"    --int-16 attempts to coerce data to 16-bit integer format",
     */

    hr = S_OK;

    CPrefs prefs(argc, argv, hr, g_plugin.m_nAudioDeviceRequestType);
    if (FAILED(hr)) {
      ERR(L"CPrefs::CPrefs constructor failed: hr = 0x%08x", hr);
      return -__LINE__;
    }
    if (S_FALSE == hr) {
      // nothing to do
      return 0;
    }

    // create a "loopback capture has started" event
    HANDLE hStartedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hStartedEvent) {
      ERR(L"CreateEvent failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeStartedEvent(hStartedEvent);

    // create a "stop capturing now" event
    HANDLE hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hStopEvent) {
      ERR(L"CreateEvent failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeStopEvent(hStopEvent);

  g_plugin.SetAudioDeviceDisplayName(prefs.m_szAudioDeviceDisplayName.c_str(), prefs.m_bIsRenderDevice);

    {
      const wchar_t* requestTypeText = L"auto";
      if (g_plugin.m_nAudioDeviceRequestType == 1) {
        requestTypeText = L"capture";
      }
      else if (g_plugin.m_nAudioDeviceRequestType == 2) {
        requestTypeText = L"render";
      }

      wchar_t configBuf[512];
      swprintf_s(
        configBuf,
        L"StartAudioCaptureThread: device='%ls' requestType=%ls isRender=%ls int16=%ls",
        prefs.m_szAudioDeviceDisplayName.c_str(),
        requestTypeText,
        prefs.m_bIsRenderDevice ? L"true" : L"false",
        prefs.m_bInt16 ? L"true" : L"false"
      );
      milkwave.LogDebug(configBuf);
    }

    // create arguments for loopback capture thread
    LoopbackCaptureThreadFunctionArguments threadArgs;
    threadArgs.hr = E_UNEXPECTED; // thread will overwrite this
    threadArgs.pMMDevice = prefs.m_pMMDevice;
    threadArgs.bIsRenderDevice = prefs.m_bIsRenderDevice;
    threadArgs.bInt16 = prefs.m_bInt16;
    threadArgs.hFile = prefs.m_hFile;
    threadArgs.hStartedEvent = hStartedEvent;
    threadArgs.hStopEvent = hStopEvent;
    threadArgs.nFrames = 0;
    threadArgs.pMilkwave = &milkwave; // provide milkwave instance for logging from the capture thread

    milkwave.LogInfo(L"StartAudioCaptureThread: CreateThread LoopbackCaptureThreadFunction");
    hThreadLoopbackCapture = CreateThread(
      NULL, 0,
      LoopbackCaptureThreadFunction, &threadArgs,
      0, NULL
    );
    if (NULL == hThreadLoopbackCapture) {
      milkwave.LogInfo(L"StartAudioCaptureThread: CreateThread failed");
      ERR(L"CreateThread failed: last error is %u", GetLastError());
      return -__LINE__;
    }
    CloseHandleOnExit closeThread(hThreadLoopbackCapture);

    // wait for either capture to start or the thread to end
    HANDLE waitArray[2] = { hStartedEvent, hThreadLoopbackCapture };
    DWORD dwWaitResult;
    dwWaitResult = WaitForMultipleObjects(
      ARRAYSIZE(waitArray), waitArray,
      FALSE, INFINITE
    );

    if (WAIT_OBJECT_0 + 1 == dwWaitResult) {
      milkwave.LogInfo(L"StartAudioCaptureThread: Thread aborted before starting to loopback capture: hr = 0x%08x");
      ERR(L"Thread aborted before starting to loopback capture: hr = 0x%08x", threadArgs.hr);
      return -__LINE__;
    }

    if (WAIT_OBJECT_0 != dwWaitResult) {
      milkwave.LogInfo(L"StartAudioCaptureThread: Unexpected WaitForMultipleObjects return value");
      ERR(L"Unexpected WaitForMultipleObjects return value %u", dwWaitResult);
      return -__LINE__;
    }

    // at this point capture is running
    // wait for the user to press a key or for capture to error out

    // /*HANDLE thread =*/ 
    // StartRenderThread(instance);
    // WaitForSingleObject(threadRender, INFINITE);

    //NEED TO STOP CAPTURE
    // at this point capture is running
    // wait for the user to press a key or for capture to error out
    {
      WaitForSingleObjectOnExit waitForThread(hThreadLoopbackCapture);
      SetEventOnExit setStopEvent(hStopEvent);

      /*
      HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

      if (INVALID_HANDLE_VALUE == hStdIn) {
          ERR(L"GetStdHandle returned INVALID_HANDLE_VALUE: last error is %u", GetLastError());
          return -__LINE__;
      }

      LOG(L"%s", L"Press Enter to quit...");

      HANDLE rhHandles[2] = { hThreadLoopbackCapture, hStdIn };
      */
      g_plugin.m_nAudioLoopState = 0;
      bool bKeepWaiting = true;
      while (bKeepWaiting) {
        if (threadRender == nullptr) {
          // render thread stopped
          bKeepWaiting = false;
        }
        else if (g_plugin.m_nAudioLoopState == 1) {
          // audio device changed
          bKeepWaiting = false;
          g_plugin.m_nAudioLoopState = 2;
        }
        else {
          Sleep(100);
        }
      } // while
    } // naked scope

    // at this point the thread is definitely finished

  // MessageBoxA(NULL, "capture loop finished", "loopback", MB_OK);

    DWORD exitCode;
    if (!GetExitCodeThread(hThreadLoopbackCapture, &exitCode)) {
      milkwave.LogInfo(L"StartAudioCaptureThread: GetExitCodeThread failed");
      ERR(L"GetExitCodeThread failed: last error is %u", GetLastError());
      return -__LINE__;
    }

    if (0 != exitCode) {
      milkwave.LogInfo(L"StartAudioCaptureThread: Loopback capture thread exit code unexpected");
      ERR(L"Loopback capture thread exit code is %u; expected 0", exitCode);
      return -__LINE__;
    }

    if (S_OK != threadArgs.hr) {
      ERR(L"Thread HRESULT is 0x%08x", threadArgs.hr);
      // return -__LINE__;
      // probably the device got disconnected, see handling for result > 0 below
      // if this is the topmost thread, do not return
      if (nestingLevel > 0) {
        return 1;
      }
    }
    // let prefs' destructor call mmioClose

    if (g_plugin.m_nAudioLoopState == 2) {
      g_plugin.AddNotificationAudioDevice();

      // not the best solution to build a thread tree like this, but too lazy/scared to refactor right now
      int result = StartAudioCaptureThread(instance, ++nestingLevel);
      if (result != 0) {
        ERR(L"StartAudioCaptureThread failed: %d", result);

        /*
        std::wstringstream ss;
        ss << L"STATUS=Device init \"" << g_plugin.m_szAudioDeviceDisplayName << "\" failed, reverting to \"" << g_plugin.m_szAudioDevicePrevious << "\"";
        statusMessage = ss.str();
        g_plugin.SendMessageToMilkwaveRemote(statusMessage.data());
        */

        // if result > 1, we probably encountered a disconnection error earlier (eg. Bluetooth headphone disconnection), 
        // and the m_szAudioDevice was already set using Ctrl+D
        if (result < 0) {
          wcscpy_s(g_plugin.m_szAudioDevice, g_plugin.m_szAudioDevicePrevious);
          bool prevIsRender = (g_plugin.m_nAudioDevicePreviousType == 2);
          g_plugin.SetAudioDeviceDisplayName(g_plugin.m_szAudioDevicePrevious, prevIsRender);
          g_plugin.m_nAudioDeviceActiveType = g_plugin.m_nAudioDevicePreviousType;
        }

        std::wstring statusMessage = L"DEVICE=" + std::wstring(g_plugin.m_szAudioDevice);
        g_plugin.SendMessageToMilkwaveRemote(statusMessage.data());
        g_plugin.AddNotificationAudioDevice();
        result = StartAudioCaptureThread(instance, ++nestingLevel);
      }
    }
  } catch (const std::exception& e) {
    milkwave.LogException(L"StartAudioCaptureThread", e, true);
  }
  return 0;
}

unsigned __stdcall DoSetup(void* param) {

  Sleep(3000); // wait for the render thread to initialize the plugin completely
  HINSTANCE instance = (HINSTANCE)param;

  if (g_plugin.m_ShaderCaching && g_plugin.m_ShaderPrecompileOnStartup) {

    std::wstring cacheDir = std::wstring(g_plugin.m_szBaseDir) + L"cache";
    std::wstring compiledListPath = cacheDir + L"\\compiled.txt";

    // Abort if compiled.txt already exists
    if (std::filesystem::exists(compiledListPath)) {
      milkwave.LogInfo(L"Shader cache already exists, skipping precompilation");
      return -1;
    }

    // Open precompile.txt
    std::ifstream file("precompile.txt");
    if (!file.is_open()) {
      milkwave.LogInfo(L"Failed to open precompile.txt");
      return -1;
    }

    // Ensure the "cache" directory exists
    try {
      std::filesystem::create_directory(cacheDir);
    } catch (const std::filesystem::filesystem_error& e) {
      milkwave.LogException(L"Failed to create cache directory", e, false);
      return -1;
    }

    // Prepare output file for compiled shader list
    std::wofstream compiledList(compiledListPath);
    if (!compiledList.is_open()) {
      std::wstring msg = L"Precompile failed to create " + compiledListPath;
      wchar_t* writableMsg = &msg[0];  // Get non-const pointer to internal buffer
      g_plugin.AddNotification(writableMsg);
      return -1;
    }

    // Set UTF-8 locale for the output stream
    compiledList.imbue(std::locale(std::locale::empty(), new std::codecvt_utf8<wchar_t>));

    g_plugin.AddNotification(L"Shader cache empty, precompiling shaders", 10 * 60);

    int compiledShaders = 0;
    std::string line;
    auto start = std::chrono::high_resolution_clock::now();
    while (std::getline(file, line)) {
      // Skip BOM if present (UTF-8)
      if (!line.empty() && line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF') {
        line.erase(0, 3);
      }

      // Convert UTF-8 to wide string properly
      std::wstring wLine;
      if (!line.empty()) {
        int size_needed = MultiByteToWideChar(CP_UTF8, 0, &line[0], (int)line.size(), NULL, 0);
        wLine.resize(size_needed);
        MultiByteToWideChar(CP_UTF8, 0, &line[0], (int)line.size(), &wLine[0], size_needed);
      }

      // Trim whitespace
      wLine.erase(0, wLine.find_first_not_of(L" \t"));
      wLine.erase(wLine.find_last_not_of(L" \t") + 1);

      // Skip empty lines or comments
      if (wLine.empty() || wLine[0] == L'#') continue;

      // Check for wildcard
      if (!wLine.empty() && wLine.back() == L'*') {
        std::wstring dirPath = wLine.substr(0, line.length() - 1); // Remove '*'
        if (std::filesystem::exists(dirPath)) {
          for (const auto& entry : std::filesystem::directory_iterator(dirPath)) {
            if (entry.is_regular_file()) {
              PrecompilePresetShaders(entry.path().wstring(), compiledList, compiledShaders);
            }
          }
        }
      }
      else {
        PrecompilePresetShaders(wLine, compiledList, compiledShaders);
      }
    }

    file.close();
    compiledList.close();
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration<double>(end - start); // fractional seconds
    std::wstringstream ss;
    ss << std::fixed << std::setprecision(2) << duration.count();

    std::wstring message = L"Precompiling " + std::to_wstring(compiledShaders)
      + L" shaders completed in " + ss.str() + L"s";

    wchar_t szMessage[256];
    wcsncpy_s(szMessage, message.c_str(), _TRUNCATE);
    g_plugin.AddNotification(szMessage, 5);
    milkwave.LogInfo(message);
  }
  return 0;
}

void PrecompilePresetShaders(std::wstring& wLine, std::wofstream& compiledList, int& compiledShaders) {
  wchar_t szFile[512];
  // Treat anything without a drive letter as relative
  if (wLine.find(L":\\") == std::wstring::npos) {
    lstrcpyW(szFile, g_plugin.m_szBaseDir);
    lstrcatW(szFile, wLine.c_str());
  }
  else {
    lstrcpyW(szFile, wLine.c_str());
  }

  // Compile the shader
  if (std::filesystem::exists(std::filesystem::path(szFile))) {
    auto start = std::chrono::high_resolution_clock::now();
    g_plugin.CompilePresetShadersToFile(szFile);
    auto end = std::chrono::high_resolution_clock::now();
    auto durationMs = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::wstring warn = L" ";
    if (durationMs > 1000) {
      // if compilation took more than 1 second, add a warning
      warn = L"!";

    }
    compiledList << warn << std::setw(8) << std::setfill(L' ') << durationMs << " " << szFile << std::endl;
    compiledShaders++;
  }
}

void StartSetupThread(HINSTANCE instance) {
  threadSetup = (HANDLE)_beginthreadex(
    nullptr,
    0,
    &DoSetup,
    (void*)instance,
    0,
    &threadId);
}

int StartThreads(HINSTANCE instance) {
  try {
    // Milkwave: early init so we can read from settings
    g_plugin.PluginPreInitialize(0, 0);

    // early assignment so we can use logging
    // milkwave.Init() may only be called after the window is created due to threading issues
    milkwave.logLevel = g_plugin.m_LogLevel;
    g_plugin.milkwave = &milkwave;

    milkwave.LogInfo(L"Milkwave initialized, LogLevel=" + std::to_wstring(milkwave.logLevel)
      + L" BaseDir=" + g_plugin.m_szBaseDir);

    if (g_plugin.m_CheckDirectXOnStartup) {
      if (!g_plugin.CheckForDirectX9c()) {
        milkwave.LogInfo(L"DirectX 9 DLL not in registry, exiting");
        return -1;
      }
      if (!g_plugin.CheckDX9DLL()) {
        milkwave.LogInfo(L"DirectX 9 DLL not found, exiting");
        return -1;
      }

      // if we made it here, skip this check in the future
      g_plugin.m_CheckDirectXOnStartup = false;
    }

    milkwave.LogInfo(L"Starting render thread");
    StartRenderThread(instance);
    // WaitForSingleObject(threadRender, INFINITE);

    milkwave.LogInfo(L"Starting setup thread");
    StartSetupThread(instance);

    if (g_plugin.m_bEnableAudioCapture) {
      milkwave.LogInfo(L"Starting audio capture thread");
      StartAudioCaptureThread(instance, 0);
    }
    else {
      milkwave.LogInfo(L"Audio capture disabled in settings");
      while (true) {
        Sleep(1000);
      }
    }

  } catch (const std::exception& e) {
    milkwave.LogException(L"StartThreads", e, true);
    return -1;
  }

  return 0;
}

void MilkwaveTerminateHandler() {
  try {
    // Re-throw the current exception to get its type/info
    std::exception_ptr exptr = std::current_exception();
    if (exptr) {
      try {
        std::rethrow_exception(exptr);
      } catch (const std::exception& e) {
        milkwave.LogException(L"Unhandled exception (std::terminate)", e, true);
      } catch (...) {
        milkwave.LogInfo(L"Unhandled non-std::exception in std::terminate");
      }
    }
    else {
      milkwave.LogInfo(L"std::terminate called with no active exception");
    }
  } catch (...) {
    // If logging itself throws, do nothing
  }
  std::abort(); // Ensure abnormal termination
}

void SeTranslatorFunction(unsigned int code, _EXCEPTION_POINTERS* ep) {
  try {
    std::ostringstream oss;
    oss << "SEH exception code0x" << std::hex << code;
    throw std::runtime_error(oss.str());
  } catch (...) {
    // If translator itself fails, rethrow as runtime_error
    throw std::runtime_error("SEH exception (unknown)");
  }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow) {
  std::set_terminate(MilkwaveTerminateHandler);
  api_orig_hinstance = hInstance;

  // Install SEH -> C++ translator so SEH (e.g., access violations) become catchable std::exception
  _set_se_translator(SeTranslatorFunction);

#ifdef _DEBUG
  // Set the current directory to the Release folder for debugging,
  // which is expected to be at the project root level.
  SetCurrentDirectoryW(L"../../Release");
  wchar_t fullPath[MAX_PATH];
  GetCurrentDirectoryW(MAX_PATH, g_plugin.m_szBaseDir);
  // swprintf(cwd, sizeof(cwd) / sizeof(cwd[0]), L"WinMain: WorkingDir=%s\n", cwd);
  // Append backslash if not present
  size_t len = wcslen(g_plugin.m_szBaseDir);
  if (len > 0 && g_plugin.m_szBaseDir[len - 1] != L'\\') {
    if (len < MAX_PATH - 1) { // Ensure space for backslash and null terminator
      g_plugin.m_szBaseDir[len] = L'\\';
      g_plugin.m_szBaseDir[len + 1] = L'\0';
    }
  }
  OutputDebugStringW(g_plugin.m_szBaseDir);
  OutputDebugStringW(L"\n");
#else
  wchar_t exePath[MAX_PATH];
  GetModuleFileNameW(NULL, exePath, MAX_PATH);

  fs::path fullPath(exePath);
  fs::path exeDir = fullPath.parent_path();

  std::wstring baseDir = exeDir.wstring();
  if (!baseDir.empty() && baseDir.back() != L'\\') {
    baseDir += L'\\';
  }

  wcscpy_s(g_plugin.m_szBaseDir, MAX_PATH, baseDir.c_str());
#endif
  int res = 0;
  try {
    res = StartThreads(hInstance);
  } catch (const std::exception& e) {
    milkwave.LogException(L"WinMain", e, true);
  }
  milkwave.LogInfo(L"WinMain ended, result=" + std::to_wstring(res));
  return res;
}

static std::string title;

#ifdef DEBUG
struct _DEBUG_STATE {
  _DEBUG_STATE() {}

  ~_DEBUG_STATE() {
    _CrtDumpMemoryLeaks();
  }
};

_DEBUG_STATE ds;
#endif